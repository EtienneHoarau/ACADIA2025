    # -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'qt_interface.ui'
#
# Created by: PyQt5 UI code generator 5.15.11
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.backends.backend_qt5agg import NavigationToolbar2QT as NavigationToolbar
from matplotlib.figure import Figure
import tensorflow as tf
import numpy as np
import matplotlib.image as mpimg
import cv2
import math

class MatPlotLibFigure(FigureCanvas):
    def __init__(self, parent=None, width=5, height=4, dpi=100):
        self.fig = Figure(figsize=(width, height), dpi=dpi)
        self.axes = self.fig.add_subplot(111)
        self.axes.axis("off")
        super(MatPlotLibFigure, self).__init__(self.fig)

    def draw(self):
        self.fig.tight_layout(pad=1)
        super(MatPlotLibFigure, self).draw()

class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(800, 600)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setEnabled(True)
        self.centralwidget.setObjectName("centralwidget")
        self.gridLayout_2 = QtWidgets.QGridLayout(self.centralwidget)
        self.gridLayout_2.setObjectName("gridLayout_2")

        # Création du GroupBox configImage
        self.configImage = QtWidgets.QGroupBox(self.centralwidget)
        self.configImage.setObjectName("configImage")
        # Création du layout configLayout
        self.configLayout = QtWidgets.QVBoxLayout(self.configImage)
        self.configLayout.setObjectName("configLayout")
        # Création du layout import_iamge_layout
        self.import_image_layout = QtWidgets.QHBoxLayout()
        self.import_image_layout.setObjectName("import_image_layout")
        self.configLayout.addLayout(self.import_image_layout)
        # Création du bouton Select a picture
        self.fileSelectButton = QtWidgets.QPushButton("Select a picture")
        self.fileSelectButton.clicked.connect(self.selectFile)
        self.input_image_path = None
        self.import_image_layout.addWidget(self.fileSelectButton)
        # Création du bouton Select a model
        self.modelSelectButton = QtWidgets.QPushButton("Select a model")
        self.modelSelectButton.clicked.connect(self.selectModel)
        self.model_path = ""
        self.model = None
        self.infer = None
        self.import_image_layout.addWidget(self.modelSelectButton)
        # Création du layout setting_threshold_layout
        self.setting_threshold_layout = QtWidgets.QHBoxLayout()
        self.setting_threshold_layout.setObjectName("setting_threshold_layout")
        self.configLayout.addLayout(self.setting_threshold_layout)
        # Création de la zone de texte pour le seuil
        self.thresholdInput = QtWidgets.QLineEdit(self.centralwidget)
        self.thresholdInput.setPlaceholderText("0.1")
        self.threshold = 0.1
        self.setting_threshold_layout.addWidget(self.thresholdInput)
        # Création du bouton pour appliquer le seuil
        self.applyThresholdButton = QtWidgets.QPushButton("Apply a threshold", self.centralwidget)
        self.setting_threshold_layout.addWidget(self.applyThresholdButton)
        self.applyThresholdButton.clicked.connect(self.applyThresholdValue)

        #☼ Création du layout pour gérer le seuil de la moyenne
        self.setting_mean_threshold_layout = QtWidgets.QHBoxLayout()
        self.setting_mean_threshold_layout.setObjectName("setting_mean_threshold_layout")
        self.configLayout.addLayout(self.setting_mean_threshold_layout)
        # Création de la zone de texte pour le seuil
        self.thresholdMeanInput = QtWidgets.QLineEdit(self.centralwidget)
        self.thresholdMeanInput.setPlaceholderText("1")
        self.mean_threshold = 1
        self.setting_mean_threshold_layout.addWidget(self.thresholdMeanInput)
        # Création du bouton pour appliquer le seuil
        self.applyMeanThresholdButton = QtWidgets.QPushButton("Apply the threshold size", self.centralwidget)
        self.setting_mean_threshold_layout.addWidget(self.applyMeanThresholdButton)
        self.applyMeanThresholdButton.clicked.connect(self.applyMeanThresholdValue)

        self.gridLayout_2.addWidget(self.configImage, 2, 0, 1, 1)
        self.input_image = QtWidgets.QGroupBox(self.centralwidget)
        self.input_image.setObjectName("input_image")
        self.input_image_layout = QtWidgets.QVBoxLayout(self.input_image)
        self.input_image_layout.setObjectName("input_image_layout")
        self.gridLayout_2.addWidget(self.input_image, 3, 0, 1, 1)
        self.output_image = QtWidgets.QGroupBox(self.centralwidget)
        self.output_image.setObjectName("output_image")
        self.output_image_layout = QtWidgets.QVBoxLayout(self.output_image)
        self.output_image_layout.setObjectName("output_image_layout")
        self.gridLayout_2.addWidget(self.output_image, 3, 2, 1, 1)
        self.error_image = QtWidgets.QGroupBox(self.centralwidget)
        self.error_image.setObjectName("error_image")
        self.error_image_layout = QtWidgets.QVBoxLayout(self.error_image)
        self.error_image_layout.setObjectName("error_image_layout")
        self.gridLayout_2.addWidget(self.error_image, 3, 4, 1, 1)
        spacerItem = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.gridLayout_2.addItem(spacerItem, 4, 0, 1, 5)
        spacerItem1 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.gridLayout_2.addItem(spacerItem1, 1, 0, 1, 1)
        spacerItem2 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.gridLayout_2.addItem(spacerItem2, 1, 2, 2, 3)
        self.label = QtWidgets.QLabel(self.centralwidget)
        self.label.setObjectName("label")
        self.gridLayout_2.addWidget(self.label, 3, 1, 1, 1)
        self.label_2 = QtWidgets.QLabel(self.centralwidget)
        self.label_2.setObjectName("label_2")
        self.gridLayout_2.addWidget(self.label_2, 3, 3, 1, 1)
        self.label_3 = QtWidgets.QLabel(self.centralwidget)
        self.label_3.setObjectName("label_3")
        self.gridLayout_2.addWidget(self.label_3, 0, 0, 1, 5)

        # Organisation du gridLayout principal
        self.gridLayout_2.setColumnStretch(0, 10)
        self.gridLayout_2.setColumnStretch(1, 1)
        self.gridLayout_2.setColumnStretch(2, 10)
        self.gridLayout_2.setColumnStretch(3, 1)
        self.gridLayout_2.setColumnStretch(4, 10)
        self.gridLayout_2.setRowStretch(0, 1)
        self.gridLayout_2.setRowStretch(1, 1)
        self.gridLayout_2.setRowStretch(2, 1)
        self.gridLayout_2.setRowStretch(3, 6)
        self.gridLayout_2.setRowStretch(4, 3)
        MainWindow.setCentralWidget(self.centralwidget)

        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)
        self.setupGraphs()

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "MainWindow"))
        self.configImage.setTitle(_translate("MainWindow", "Image import"))
        self.input_image.setTitle(_translate("MainWindow", "Input image"))
        self.output_image.setTitle(_translate("MainWindow", "Output image"))
        self.error_image.setTitle(_translate("MainWindow", "Difference"))
        self.label.setText(_translate("MainWindow", "-"))
        self.label_2.setText(_translate("MainWindow", "="))
        self.label_3.setText(_translate("MainWindow", "<html><head/><body><p align=\"center\"><span style=\" font-size:24pt;\">ACADIA</span></p></body></html>"))

    def resizeEvent(self, event):
        size = min(self.input_image.width(), self.input_image.height())
        self.input_image.setFixedSize(size, size)
        self.output_image.setFixedSize(size, size)
        self.error_image.setFixedSize(size, size)
        event.accept()

    # Foncion initialisant les figures MatPlotLib
    def setupGraphs(self):
        self.input_canva = MatPlotLibFigure(self.centralwidget)
        self.input_image_layout.addWidget(self.input_canva, stretch=1)
        self.output_canva = MatPlotLibFigure(self.centralwidget)
        self.output_image_layout.addWidget(self.output_canva, stretch=1)
        self.error_canva = MatPlotLibFigure(self.centralwidget)
        self.error_image_layout.addWidget(self.error_canva, stretch=1)

    # Fonction permettant de sélectionner une image
    def selectFile(self):
        filename, _ = QtWidgets.QFileDialog.getOpenFileName(None, "Open Image", "", "Image Files (*.png *.jpg *.bmp)")
        if filename:
            self.input_image_path = filename
            print("File selected :", self.input_image_path)
            self.updateImages()
        else:
            print("No selected file")

    # Fonction permettant de sélectionner un modèle
    def selectModel(self):
        foldername = QtWidgets.QFileDialog.getExistingDirectory(None, "Select the model directory")
        if foldername:
            self.model_path = foldername
            print("Folder selected :", self.model_path)
            self.updateImages()
            self.load_model()
        else:
            print("No selected folder")

    # Fonction permettant de charger le modèle sélectionnant
    def load_model(self):
        self.model = tf.saved_model.load(self.model_path)
        self.infer = self.model.signatures["serving_default"]
        print("✅ Modèle chargé avec succès :", self.model_path)

    # Fonction permettant de redimensionner les images de sorte à pouvoir les soustraire
    def preprocess_image(self, image_path):
        image = cv2.imread(image_path)
        image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
        image = cv2.resize(image, (512, 512))
        image = np.where(image > self.shadow_threshold, image, 140 / 255)
        image = image / 255.0
        image = np.expand_dims(image, axis=0)
        return image

    # Fonction permettant d'envoyer une image donnée dans l'auto-encodeur
    def predict_image(self, image_path):
        if self.model is not None:
            image = self.preprocess_image(image_path)
            prediction = self.infer(tf.constant(image, dtype=tf.float32))
            output_key = list(prediction.keys())[0]
            return np.squeeze(prediction[output_key].numpy(), axis=0)

    # Fonction permettant de calculer le PSNR entre l'image donnée en entrée et l'image reconstruite
    def compute_psnr(self, original, reconstructed):
        mse = np.mean((original - reconstructed) ** 2)
        if mse == 0:
            return float('inf')  # PSNR infini si pas d'erreur
        max_pixel = 1.0  # Normalisation entre 0 et 1
        psnr = 20 * math.log10(max_pixel / math.sqrt(mse))
        return psnr

    # Fonction permettant d'appliquer une taille de seuil
    def applyMeanThresholdValue(self):
        meanThreshold = self.thresholdMeanInput.text()
        if meanThreshold:
            try:
                self.mean_threshold = int(meanThreshold)
                print(f"Threshold size : {self.mean_threshold}")
                self.updateImages()
            except ValueError:
                print("Please enter a correct value.")

    # Fonction permettant d'appliquer une valeur de seuil
    def applyThresholdValue(self):
        threshold = self.thresholdInput.text()
        if threshold:
            try:
                self.threshold = float(threshold)
                print(f"Threshold applied : {self.threshold}")
                self.updateImages()
            except ValueError:
                print("Please enter a correct value.")

    # Fonction permettant d'appliquer le seuil enfonction des paramètres entrés précédemment
    def applyThreshold(self, img):
        if self.threshold == 0:
            print("No threshold")
            return img
        # Calcul de la moyenne locale avec un noyau de convolution
        kernel = np.ones((self.mean_threshold, self.mean_threshold), np.float32) / (self.mean_threshold ** 2)
        local_mean = cv2.filter2D(img, -1, kernel)

        # Appliquer le seuillage en utilisant np.where
        thresholded_img = np.where(local_mean > self.threshold, local_mean, 0)

        return thresholded_img

    # Fonction mettant à jour les images 
    def updateImages(self):
        print("Mise à jour des images")
        print("Modèle utilisé :", self.model_path)
        print("Image utilisée :", self.input_image_path)
        input_img = self.preprocess_image(self.input_image_path) if self.input_image_path else None

        if input_img is not None:
            input_img = np.squeeze(input_img, axis=0)

        self.input_canva.axes.clear()
        self.input_canva.axes.set_axis_off()  # Cache les axes
        if input_img is not None:
            input_img = np.where(input_img > self.shadow_threshold, input_img, 140 / 255)
            self.input_canva.axes.imshow(input_img)
        self.input_canva.draw()

        output_img = self.predict_image(self.input_image_path) if input_img is not None and self.model_path else None

        if input_img is not None and output_img is not None:
            psnr_value = self.compute_psnr(input_img, output_img)
            print("PSNR :", psnr_value)


        self.output_canva.axes.clear()
        self.output_canva.axes.set_axis_off()  # Cache les axes
        if output_img is not None:
            self.output_canva.axes.imshow(output_img)
        self.output_canva.draw()

        if input_img is not None and output_img is not None:
            # Calcul de l'erreur comme la différence maximale sur les 3 canaux
            error_img = np.max(np.abs(input_img - output_img), axis=-1)
            error_img = self.applyThreshold(error_img)
            error_img = np.squeeze(error_img)

            self.error_canva.axes.clear()
            self.error_canva.axes.set_axis_off()  # Cache les axes
            # Afficher l'erreur
            self.error_canva.axes.imshow(error_img, cmap="hot")
            self.error_canva.draw()

if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    MainWindow.show()
    sys.exit(app.exec_())



